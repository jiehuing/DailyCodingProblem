The game of Nim is played as follows. Starting with three heaps, each containing a variable number of items,
two players take turns removing one or more items from a single pile. The player who eventually is forced to take the last stone loses. 
For example, if the initial heap sizes are 3, 4, and 5, a game could be played as shown below:

  A  |  B  |  C
-----------------
  3  |  4  |  5
  3  |  1  |  3
  3  |  1  |  3
  0  |  1  |  3
  0  |  1  |  0
  0  |  0  |  0 
In other words, to start, the first player takes three items from pile B. The second player responds by removing two stones from pile C.
The game continues in this way until player one takes last stone and loses.

Given a list of non-zero starting values [a, b, c], and assuming optimal play, determine whether the first player has a forced win.



Attempt
the pile can be split into three states
0, 1, 1+
Since 1+ can just be removed to 1 or 0.
Brute Force

Case 0
0 0 0 
No Game

Case 1
0 0 1
First player Lose

Case 2
0 1 1
First player win

Case 3
1 1 1
First Player lose

Case 4
0 0 1+
First Player wins

Case 5
0 1 1+
First Player wins

Case 6
1 1 1+
First player can force it to case 3 for player 2, First player win

Case 7
0 1+ 1+
Testing our hypothesis with
0 3 3
since we can reduce it to 0 1 1,
First player will win.
Let's try
1st   0 3 2
2nd   0 2 2
1st   0 1 2
2nd   0 1 0
2nd player win

let's see if there is another way for player 1 to force a win.
1st   0 3 1
2nd   0 0 1
2nd player win

Taking 3
1st   0 3 0
2nd   0 1 0
2nd player wins

Testing case 7 with
      0 2 2
1st   0 1 2
2nd   0 1 0
2nd player win

      0 2 2
1st   0 0 2
2nd   0 0 1
2nd players win


Hypothesis
See how 0 2 2 and 0 3 3 are even?
Maybe even odd state determines win loss
0 2 3 can be reduced to 0 2 2 so if odd means player 1 win
This does not applies to 0 1 1 though. Separate cases.

Testing case 7 with
      0 4 4
1st   0 4 3
2nd   0 3 3
2nd Player win

      0 4 4
1st   0 4 2
2nd   0 2 2
2nd Player win

      0 4 4
1st   0 4 1
2nd   0 0 1
2nd Player wins

      0 4 4
1st   0 0 4
2nd   0 0 1
2nd Player wins

Hypothesis seems invalid for 0 4 2
We need to find remainder for 4

Interject
To determine the type of cases, we can use regex.

Case 7 (odd player 1 wins, even, player 2 wins)


Case 8
1 1+ 1+
if 1 even,
Player 1 wins by removing the first stone
if 1 odd,
Player 1 loses

Test 
      1 4 5
1st   1 2 5
2nd   1 2 2
1st   1 2 1
2nd   1 1 1
Case 3 First player lose

      1 4 5
 1st  1 4 1
 2nd  1 1 1
 Case 3 First Player lose
 
      1 4 5
1st   1 4 2
2nd   1 2 2
1st   1 1 2
2nd   1 1 1
Case 3 First Player lose

      1 2 3
1st   1 2 2
2nd   1 1 2
1st   1 1 1
Case 3 First player wins?


Case 9
1+ 1+ 1+
This is the most interesting case
if 3 4 5
Player 1 can force a win by taking out 1st stack if remaining is even.
If remaining is odd, player 1 can switch the outcome by leaving a 1 in the first column.
Player 1 always wins.

Test 



pseudo code
Base is 0 0 0
boolean player1Wins = true
go through each number
if number = 0, do nothing
if number = 1, player1Wins != player1 Wins (this will flip player1Wins boolean, true to false, false to true)
if number > 1, 



Provided Solution
The game of Nim is played as follows. Starting with three heaps, each containing a variable number of items, two players take turns removing one or more items from a single pile. The player who eventually is forced to take the last stone loses. For example, if the initial heap sizes are 3, 4, and 5, a game could be played as shown below:

  A  |  B  |  C
-----------------
  3  |  4  |  5
  3  |  1  |  3
  3  |  1  |  3
  0  |  1  |  3
  0  |  1  |  0
  0  |  0  |  0 
In other words, to start, the first player takes three items from pile B. The second player responds by removing two stones from pile C. The game continues in this way until player one takes last stone and loses.

Given a list of non-zero starting values [a, b, c], and assuming optimal play, determine whether the first player has a forced win.

Solution
Since we are dealing with a two-player game, one approach to solve this is to apply a minimax algorithm.

For the base case, we know that if the piles dwindle down to (0, 0, 0), the current player to move is the winner, since the last player must have removed the final stone.

Now let's say you are faced with the heaps (1, 3, 0). There are many possible moves, but the only good one is to remove everything in pile B, so that your opponent is forced to take the item in pile A. For any other move, there is a response that makes this a losing game. In other words, the value of a given move to player one is equivalent to the value of the best response to player two.

The list of possible moves can be generated by taking between one and all items from each pile. As a result, we can define a recursive solution that enumerates all possible moves, and returns True if any of them prevent the opponent from making an optimal move.

def update(heaps, pile, items):
    heaps = list(heaps)
    heaps[pile] -= items
    return tuple(heaps)

def get_moves(heaps):
    moves = []

    for pile, count in enumerate(heaps):
        for i in range(1, count + 1):
            moves.append(update(heaps, pile, i))

    return set(moves)

def nim(heaps):
    if heaps == (0, 0, 0):
        return True

    moves = get_moves(heaps)

    return any([not nim(move) for move in moves])
At the start of the game, if each pile has a, b, and c items respectively, there will be a + b + c possible moves, which we can denote by N. Unfortunately, because of our recursive approach, each subsequent move may only bring the number of items down by one, leading to a run time of O(N!).

We can improve this with memoization. Each time we find the result for a given heap configuration, we store it in a dictionary. Before calculating the value of a given heap, we check this dictionary, and if the key exists we can avoid unnecessary work.

def nim(heaps, results={}):
    if tuple(heaps) in results:
        return results[tuple(heaps)]

    if heaps == (0, 0, 0):
        return 1

    moves = get_moves(heaps)
    results[tuple(heaps)] = max([1 - nim(move) for move in moves])

    return results[tuple(heaps)]
This solution will run in O((a * b * c) * N), since there are a * b * c possible configurations of heaps to compute, and each one will take O(N) time to generate moves.

In fact, though, there is a bitwise solution to this game that is only O(1)!

Note that the losing state, (0, 0, 0), has an xor product, or "nim-sum", of 0. Though it is trickier it see, it is also the case that for any given state it is possible to make a move that turns this product from zero to non-zero, and vice versa. Therefore, we can use the nim-sum after each pair of moves as an invariant.

More concretely, if you are playing Nim, and for a given move your opponent turns the nim-sum from 0 to 3, you can make a move that turns it back to zero, putting your opponent back in a losing state. As a result, with the exception of one special case, a game is a win for the first player if and only if its nim-sum is nonzero.

def nim(heaps):
    a, b, c = heaps
    if a == b == c == 1:
        return False

    return a ^ b ^ c != 0


